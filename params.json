{
  "name": "Yoctoscheduler-core",
  "tagline": "A cloud-aware (multi-process, self-healing) SQL Server Agent alternative",
  "body": "# YoctoScheduler\r\n\r\n[![MIT licensed](https://img.shields.io/badge/license-MIT-blue.svg)](https://raw.githubusercontent.com/hyperium/hyper/master/LICENSE)\r\n\r\n## Intro\r\nYoctoScheduler is a multi-thread, multi-process scheduling system. It is meant to be a SQL Server Agent alternative for Azure workloads.  \r\nEach server in  a cluster should be independent from the others while maintaining some architectural constraints.\r\n\r\nThe configuration data is stored in an Azure SQL Database or SQL Server database. Each scheduler process will start, read the configuration from the shared database and start processing tasks.\r\nThe schedulers are *greedy*, meaning they compete for tasks to execute. You can control how many instances of a task can start concurrently (both on the same server and globally) via a specific configuration option. The schedules, however, are guaranteed to be executed only once (this is different from multi instance SQL Server Agent, i.e. in AlwaysOn AG in which you have to manually handle concurrency) so you don't need to concern yourself with it.\r\nThe tasks can be:\r\n  * T-SQL tasks (ie everything you can do from a SqlConnection).\r\n  * SSIS tasks (provided you have SSIS engine available).\r\n  * PowerShell tasks.\r\n\r\nAs this version there is no workflow manager. Each task is independent. Depending on the need of this we will implement the feature in the future.\r\n\r\n### Some uses\r\n\r\nYoctoScheduler has been successfully employed to:\r\n* Perform scheduled maintenance on Azure SQL Database(s)\r\n* Generate reports on timely basis\r\n* ETL in the cloud (both hybrid and pure)\r\n* Handle AlwaysOn Availability groups jobs.\r\n\r\n### Resiliency\r\n\r\nThe schedulers are build with the cloud in mind. That means they are resilient: you can have a scheduler pick up a task previously being run by another, failed, scheduler. This happens automatically and, of course, you can opt out if you want.\r\n\r\nThis is an example of what can happen. Suppose we have two instances of our scheduler (maybe in an availability group):\r\n\r\n![](docs/imgs/res_00.png)\r\n\r\nSuppose now Server_A picks up a task (called Job_01) and starts executing it:\r\n\r\n![](docs/imgs/res_01.png)\r\n\r\nJob_01 can be running as result of a schedule or maybe we just started it manually. It does not matter. What matter is we marked Job_01 as *restartable* in case of server failure.\r\n\r\nNow let's suppose Server_A fails.\r\n\r\n![](docs/imgs/res_02.png)\r\n\r\nServer_B, after declaring Server_A dead, will pick Job_01 and start executing again.\r\n\r\n![](docs/imgs/res_03.png)\r\n\r\nThis does not require manual intervention. Please note that the scheduler does not make assumption on the atomicity of the task restarted. It's up to you to provide transactionality (if needed).\r\n\r\n## Legend\r\n\r\nEntity Name | Description\r\n------------|---------|\r\nTask | Atomic execution block. A task will never migrate between servers. |\r\nServer | Scheduler and executor process. A server manipulates the companion database.\r\nTask status | A ```task``` can either be alive or dead. If not alive there is also a description of why is not running.\r\nSchedule | A predefined fire time for a ```Task```. It supports the ```NCronTab``` syntax to be flexible (up to the single minute).\r\nWorkflow | A collection of task to be orchestrated as a single entity.\r\n\r\n## Requisites\r\n\r\n### Done\r\n* Each server must be independent and must rely on the companion database only.\r\n* A schedule must fire at most *once*.\r\n* If a schedule fires when there are no servers running the schedule is *lost*.\r\n* Each task should be atomic and transactional. A task might fail at any moment and can be restarted on the same server (or another one).\r\n  > this constraint can be relaxed at first\r\n* Each task must update its status at least each ***to_define_task_update_frequency*** seconds. An update will update the ```LastUpdate``` field in the ```[live].[ExecutionStatus]``` table.\r\n* A task not updating its status for ***to_define_task_timeout*** seconds is considered dead. A dead task will be removed from the ```[live].[ExecutionStatus]``` table and placed in the ```[dead].[ExecutionStatus]``` table (along with a specific status).\r\n* A dead task will be restarted if so specified (the ***restart logic is to be defined***).\r\n* Each task can specify concurrency limits, both globally and in the same server. For example, a task might run on an unlimited number of different servers but each server should only run one instance. The concurrency check must be performed by the server at runtime at it should be conservative: better to avoid starting a task is there's the possibility of exceeding the maximum configured parallelism even if it's not a certainty.\r\n* Each task should read its configuration from the centralized server (to encourage task independence).\r\n* Required tasks:\r\n  * T-SQL task\r\n  * PowerShell task\r\n  * SSIS task\r\n\r\n\r\n### To-do\r\n\r\n#### Mandatory\r\n* PowerShell cmdlets. They are fairly easy to implement as they can only wrap the REST API calls.\r\n\r\n#### Nice to have\r\n* Linux support (via .net core).\r\n* Tasks that spawn another task(s) as result of their elaboration.\r\n* Workflows that chain task based on:\r\n  * Status (successful, failed, in exception)\r\n  * Constant match (i.e. ```if return number = 1 then ... else if ...```)\r\n  * Resources available\r\n* Fair scheduler. Scheduler should pick up tasks inspecting the available resources (to better scale in parallel).\r\n\r\n## Requisites\r\n\r\n* SQL Server 2012+ or SQL Azure database.\r\n* A database and a ```dbo_owner``` user with relative login.\r\n* C# 4.5.2.\r\n\r\n## Installation\r\nYoctoScheduler can run in two modes, as a command line program or as a Windows Service. The [configuration](docs/configuration.md) is the same, the only difference is in the command line switches that either start the command line execution or register the windows service.\r\n\r\n1. Execute the [oop-tsql/00-create.sql](tsql/00-create.sql) script on your chosen database instance. This will create the required database.\r\n2. Create a login in the database instance and give it ```db_owner``` on the previously created database.\r\n3. Compile the executable and relative libraries.\r\n4. [Configure](docs/configuration.md) the service file.\r\n5. Run (for testing purposes you may want to start with the command line program).\r\n6. *optional* Clone the web frontend (it's in a separate project right now). Once cloned make sure to configure the server files accordingly.\r\n\r\n## Configuration\r\n\r\nSee the specific section: [configuration](docs/configuration.md).\r\n\r\n## Interaction\r\n\r\nCheck out the [REST API reference](docs/rest/rest.md), the command line commands are deprecated and will be removed in the future.\r\n\r\n## Testing\r\n\r\nHere are some testing REST commands you can send to your YoctoScheduler instance. All the commands are server-agnostic so there is no difference based on which server instance you pick. Also note this samples use the Linux curl command line tool. You can download a copy for Windows from [wingw.org](http://www.mingw.org/) but some commands might require some tweaking as windows and Linux handle special characters differently.\r\n\r\n### Secret\r\n\r\nYou can create a secret using the [```SecretItems```](docs/rest/secret-item.md) REST API command. You have to specify the certificate thumbprint (as found in ```My``` certificate store) and the text to encrypt. The Secret name must be unique otherwise the call will fail.\r\n\r\n```\r\ncurl -X POST -H \"Content-Type: application/json\" cantun.mindflavor.it:9000/api/secretitems -d '{\"Name\":\"MyConnectionString\", \"CertificateThumbprint\":\"277103c882995da2d199050e58522d364513307e\", \"PlainTextValue\":\"data source=vSQL14A.mindflavor.it;initial catalog=YoctoScheduler;User Id=fagiolo;Password=cotto;MultipleActiveResultSets=False;App=YoctoTask\"}\"'\r\n```\r\n\r\nYou can call the same REST API in a browser to get the secret list:\r\n\r\n![](docs/imgs/00.png)\r\n\r\nNotice how the value is stored in its encrypted format only.\r\n\r\n*Note:* There is a bug in PowerShell generated certificates. See the [```System.Security.Cryptography.CryptographicException: Invalid provider type specified```](docs/known-issues/System.Security.Cryptography.CryptographicException.md) known issue about how to resolve this.\r\n\r\n### Task\r\nYou can add a new mock task calling the [Tasks REST API](docs/rest/tasks.md) interface.\r\n\r\nIn a nutshell the task is defined by:\r\n* Name\r\n* Type (TSQL task, PowerShell task, etc...)\r\n* Server failure resiliency (whether it should be executed again if the hosting server dies before its completion)* Concurrency limits (both global and local, use 0 for unconstrained)\r\n* Payload (task-dependent)\r\n\r\n#### Wait task\r\nFor example this is how to create a ```WaitTask``` (useful only for debugging purposes):\r\n\r\n```\r\ncurl -X POST -H \"Content-Type: application/json\" cantun.mindflavor.it:9000/api/tasks -d '{\"Name\":\"MyWaitTask\", \"ConcurrencyLimitGlobal\":0, \"ConcurrencyLimitSameInstance\":1, \"Description\":\"This task will stall the thread for 35 seconds. This task will task will not be requeued in case the server owning it dies\", \"ReenqueueOnDead\":false,\"Type\":\"WaitTask\",\"Payload\":\"{\\\"SleepSeconds\\\":35}\"'\r\n```\r\n\r\nYou can create a ```WaitTask``` using the web app by clicking Add in the Task view:\r\n\r\n![](docs/imgs/07.png)\r\n\r\n> *Warning*: images might refer to an outdated WebApp version. The relevant pieces should be valid all the same.\r\n\r\n#### T-SQL task\r\nHere is how you create a ```TSQLTask```:\r\n\r\n```\r\ncurl -X POST -H \"Content-Type: application/json\" cantun.mindflavor.it:9000/api/tasks -d '{\"Name\":\"MyDBTask_WithWait\", \"ConcurrencyLimitGlobal\":2, \"ConcurrencyLimitSameInstance\":2,  \"Description\":\"SELECT @@VERSION after WAITFOR DELAY of 30 seconds\", \"ReenqueueOnDead\":true,\"Type\":\"TSQLTask\",\"Payload\":\"{\\\"ConnectionString\\\":\\\"%%[MyConnectionString]%%\\\", \\\"Statement\\\":\\\"WAITFOR DELAY \\u002700:00:30\\u0027; SELECT @@VERSION;\\\",\\\"CommandTimeout\\\":600}\"'\r\n```\r\n\r\nFor reference, here is the above task's payload:\r\n\r\n```json\r\n{\r\n  \"Name\": \"MyDBTask_WithWait\",\r\n  \"ConcurrencyLimitGlobal\": 2,\r\n  \"ConcurrencyLimitSameInstance\": 2,\r\n  \"Description\": \"SELECT @@VERSION after WAITFOR DELAY of 30 seconds\",\r\n  \"ReenqueueOnDead\": true,\r\n  \"Type\": \"TSQLTask\",\r\n  \"Payload\": \"{\\\"ConnectionString\\\":\\\"%%[MyConnectionString]%%\\\", \\\"Statement\\\":\\\"WAITFOR DELAY '00:00:30'; SELECT @@VERSION;\\\",\\\"CommandTimeout\\\":600\"\r\n}\r\n```\r\n\r\nNotice how you can embed the ```Secret``` surrounding it with ```[%%``` and ```%%]```. This syntax is supported by JSON based tasks.\r\n\r\nYou can create T-SQL tasks and display the existing ones using the ```REST API``` or using the YoctoScheduler web app:\r\n\r\n![](docs/imgs/06.png).\r\n\r\nNotice how the WebApp makes sure you're passing the parameters correctly.\r\n\r\n#### PowerShell task\r\n\r\nPowerShell tasks accept only one parameter: Script. The output entries will be JSON serialized row by row (calling ```ToString()``` on them first). Here is an example that enumerates local drives along with used and free space:\r\n\r\n```\r\ncurl -X POST -H \"Content-Type: application/json\" cantun.mindflavor.it:9000/api/tasks -d '{\"Name\":\"My_PS_Drives\", \"ConcurrencyLimitGlobal\":0, \"ConcurrencyLimitSameInstance\":1, \"Description\":\"This task will enumerate local drives\", \"ReenqueueOnDead\":true,\"Type\":\"PowerShellTask\",\"Payload\":\"{\\\"Script\\\":\\\"Get-PSDrive | foreach { $_.Name, $_.Root, $_.Used, $_.Free | Out-String }\\\"}\"'\r\n```\r\n\r\nFor reference, here is the configuration JSON:\r\n\r\n```json\r\n{\r\n  \"Name\": \"My_PS_Drives\",\r\n  \"ConcurrencyLimitGlobal\": 0,\r\n  \"ConcurrencyLimitSameInstance\": 1,\r\n  \"Description\": \"This task will enumerate local drives\",\r\n  \"ReenqueueOnDead\": true,\r\n  \"Type\": \"PowerShellTask\",\r\n  \"Payload\": \"{\\\"Script\\\":\\\"Get-PSDrive | foreach { $_.Name, $_.Root, $_.Used, $_.Free | Out-String }\\\"}\"\r\n}\r\n```\r\n\r\nThe output, as stated above, is serialized to a JSON. In my case this is the output:\r\n\r\n```json\r\n[\r\n  {\r\n    \"Row\": \"Alias\\r\\n\\r\\n\"\r\n  },\r\n  {\r\n    \"Row\": \"C\\r\\nC:\\\\\\r\\n590391623680\\r\\n304360370176\\r\\n\"\r\n  },\r\n  {\r\n    \"Row\": \"Cert\\r\\n\\\\\\r\\n\"\r\n  },\r\n  {\r\n    \"Row\": \"E\\r\\nE:\\\\\\r\\n165277347840\\r\\n334827339776\\r\\n\"\r\n  },\r\n  {\r\n    \"Row\": \"Env\\r\\n\\r\\n\"\r\n  },\r\n  {\r\n    \"Row\": \"F\\r\\nF:\\\\\\r\\n0\\r\\n\"\r\n  },\r\n  {\r\n    \"Row\": \"Function\\r\\n\\r\\n\"\r\n  },\r\n  {\r\n    \"Row\": \"G\\r\\nG:\\\\\\r\\n0\\r\\n\"\r\n  },\r\n  {\r\n    \"Row\": \"H\\r\\nH:\\\\\\r\\n164171661312\\r\\n836029329408\\r\\n\"\r\n  },\r\n  {\r\n    \"Row\": \"HKCU\\r\\nHKEY_CURRENT_USER\\r\\n\"\r\n  },\r\n  {\r\n    \"Row\": \"HKLM\\r\\nHKEY_LOCAL_MACHINE\\r\\n\"\r\n  },\r\n  {\r\n    \"Row\": \"Variable\\r\\n\\r\\n\"\r\n  },\r\n  {\r\n    \"Row\": \"W\\r\\nW:\\\\\\r\\n97070129152\\r\\n142726615040\\r\\n\"\r\n  },\r\n  {\r\n    \"Row\": \"WSMan\\r\\n\\r\\n\"\r\n  }\r\n]\r\n```\r\n\r\nYou can pivot it in a table using SQL Server 2016 JSON features like this:\r\n\r\n```sql\r\nDECLARE @var NVARCHAR(MAX);\r\nSELECT @var = ReturnCode FROM [YoctoScheduler].[dead].[ExecutionStatus] S INNER JOIN [YoctoScheduler].[live].[Tasks] T ON S.TaskID = T.TaskID\r\nWHERE T.[Type] = 'PowerShellTask' AND GUID = '3B3B80D2-30A7-4D84-9486-16FB890603DC'\r\n\r\nSELECT *\r\n FROM OPENJSON (@var, '$')\r\n WITH (\r\n        Row NVARCHAR(MAX)\r\n ) AS OrdersArray\r\n```\r\n\r\n![](docs/imgs/05.png)\r\n\r\nYou can use the WebApp to create ```PowerShell``` tasks too.\r\n\r\n### Schedule\r\n\r\nTo add a schedule just call the [```schedules``` REST API](docs/rest/schedule.md) interface. For example this command will schedule the task with ID 1 every minute:\r\n\r\n```\r\ncurl -X POST -H \"Content-Type: application/json\" cantun.mindflavor.it:9000/api/schedules -d '{\"Cron\":\"* * * * *\",\"Enabled\":true,\"TaskID\":1}'\r\n```\r\n\r\nSchedules support the CRON syntax via [NCrontab](https://github.com/atifaziz/NCrontab). For details please refer here: [https://github.com/atifaziz/NCrontab](https://github.com/atifaziz/NCrontab).\r\n\r\nSchedules can be retrieved via REST interface. The web app does not yet support creating schedules but should be developed soon.\r\n\r\n## Direct Execution\r\n\r\nYou can also enqueue a task for immediate execution instead of scheduling it. Just call the [```queueitems``` REST API](docs/rest/queueitem.md) interface specifying the TaskID and its priority:\r\n\r\n```\r\ncurl -X POST -H \"Content-Type: application/json\" cantun.mindflavor.it:9000/api/queueitems -d '{\"TaskID\":1,\"Priority\":1}'\r\n```\r\n\r\nScheduled task will start as soon as the concurrency conditions are met. You can also query the execution queue using the same interface.\r\n\r\nYou can enqueue a task to be executed using the web interface under the task section. Notice you can pick the priority:\r\n\r\n![](docs/imgs/08.png)\r\n\r\n> Right now you cannot choose which server will execute the task. Is this right or we should change it?\r\n\r\n## Execution Lists\r\n\r\nThere are three different ```REST API``` interfaces for execution inspection: [alive](docs/rest/LiveExecution.md) and [completed](docs/rest/DeadExecution.md) executions.  You can also call the global [executions](docs/rest/executions.md) which will include both plus the queued tasks. These interfaces are GET only, that is you cannot post to them. The global will support delete in order to remove old entries. The ```Executions``` tab in the web interface shows the tasks, grouped by status:\r\n\r\n![](docs/imgs/09.png)\r\n\r\nThe Task web app page updates itself so you don't need to refresh it.\r\n\r\n## Known issues\r\n\r\n* [```System.Security.Cryptography.CryptographicException: Invalid provider type specified```](docs/known-issues/System.Security.Cryptography.CryptographicException.md).\r\n\r\n* [```Access denied``` during Owin initialization](docs/known-issues/owin-access-denied.md).\r\n\r\n* [```Bad Length``` during secret encryption](docs/known-issues/bad-length-encryption.md).\r\n\r\n\r\n## Debug\r\n\r\nTODO\r\n\r\n## License\r\nPlease see the [LICENSE](LICENSE) file for details.\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}